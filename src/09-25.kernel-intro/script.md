# level0 introduction

尝试解答的问题: 
1. 什么在内核态执行, 什么在用户态执行?
2. 为什么计算机能够做如此多的事情? 
3. POSIX 是什么? 
4. 内核的结构是什么?
5. 编写内核结构的逻辑是什么?
6. 冯诺伊曼结构是什么?
7. 内核的边界
8. 分层的概念
## 前奏 
这是一台计算机,这是另外一台计算机.
对于大部分人来说, 个人计算机要做的事情,无非是将一个信息, 发送到另外一个使用者的电脑当中. 
(画面是你好, 然后转义成二进制, 然后移动到另外一台电脑当中,两个方框.)
这个信息, 可以是文字, 视频, 也可以是图片. 
(将文字变换成一张图片,一个电影FBI WARNING)
那么作为一个运行在计算机当中的操作系统的内核, 主要任务又是什么?

聊到这个, 我们先从最开始的模拟说起

## 信息模拟与冯诺伊曼结构
当你在计算机当中,书写的一个字母, 是可以通过一个数字来表达, 比如说, A 在电脑当中的数字是 65, 被转换成二进制以后, 就是 01000001
不仅仅数字, 红色是 #FF0000, 转换成二进制后, 就是 111111110000000000000000(8个1, 16个0)
更泛化一些, 我们所有的在互联网上流通的信息,包括文件,游戏,视频,音乐,甚至银行卡的余额, 他们都会变成二进制的信息.在计算机当中流转.

即然所有的信息都可以被二进制所描述,一个计算机所要做的事情,就是将无数的二进制进行处理即可.
所以最简单的计算机就是: 
一个 CPU 负责运算, 将一堆二进制变成另外一堆二进制.
然而纯粹的处理是一个理想化的世界, 在真实的世界中,有很多的异常情况,比如说除0错误,数据获取错误等等.
这个时候,我们需要控制程序就跳转到二进制的某个位置来对这些情况进行处理.
还有, 我们需要将这些二进制保存起来.
最后, 我们需要修改以及看到我们输出的内容.

以上的这些操作, 基本上就覆盖了我们对二进制的所有操作, 也是传说中的冯诺伊曼体系: 

控制,计算, 存储,输入, 输出

我们会从一个信息跳转到另外一个信息, 控制
我们会需要运算或修改部分的信息, 计算
我们会将二进制存储在硬盘中, 存储
我们会将自己的信息转换成二进制从键盘或者相机输入到计算机中, 输入
我们会将信息输出在显示器上, 输出

# level-1 最为抽象的协议

## 无数的硬件
在冯诺伊曼的框架下, 庞大的运算需求驱动了各种硬件的诞生. 
cpu 有 AMD 的 arm 体系, intel 的x86体系, 还有开源的 risc-v 体系.
存储有 高速内存, 硬盘, sd 卡,u 盘
output 有显示器, 打印机, 耳机
input 有键盘, 鼠标, 麦克风等等.

而应用的研发人员很不开心, 他们会说, 我们是负责计算的人员, 我们没有必要要了解这些硬件怎么工作的.
我们只希望自己做运算,并且,最好有一个东西能够帮我们管理这些硬件. 

需求只有以下几个: 
- 运行计算任务
- 处理出错情况
- 多任务运行
- 看运算进度.
- 不希望了解所有的硬件

这些需求, 也就催生了POSIX, 可移植操作系统接口
应用研发人员使用 POSIX 接口, 而操作系统专注与实现 POSIX 接口.

我们以 1988 年的 posix.1 版本为例, 其涉及的就是
## posix
- Process Creation and Control 进程的创建与控制 (WAIT, EXIT)
- Signals 信号 (KILL)
  - Floating Point Exceptions 浮点运算异常
  - Bus Errors 硬件异常
  - Timers 时钟中断
- File and Directory Operations 文件操作 (OPEN, CLOSE, READ)
- I/O Port Interface and Control 输入输出端口及其控制 (SOCKET, BIND ,READ)
- Process Triggers 进程启动 (FORK, EXEC)

## what is kernel

有了这些基础信息以后, 让回到最初的问题, 内核是什么? 
内核就是,实现了类似 POSIX 标准的系统调用,可以驱动各种硬件,去实现我们高效运算任务的一个软件.

# level2 看视频的你, 会考虑怎么去设计呢?

## 内核的结构

内核的首要任务, 就是能够驱动各种硬件, 所以在针对每一个硬件, 都应该要有自己的驱动程序.

对于每一个应用开发人员来说, 他们所需要了解的, 就是一个一个的计算任务. 每一个计算任务, 我们将其称之为进程.
而保存这些进程代码, 我们就需要文件管理系统.
上网就更不必说了,我们需要实现网络协议栈,这样,当我们将网线插入网卡的时候,计算机就知道如何通过网络联系其他的计算机.
内核拥有驱动了内存, 以及磁盘的能力以后, 他就需要为每一个程序申请自己的内存. 这个时候, 内存管理也就应运而生.

最最关键的,计算机是要给人用的, 所以,我们需要用鼠标,键盘等设备去通知计算机,你该执行下一个程序了.
而这种通知的能力,就是中断控制系统来参与的.
最常见的中断就包括, 软件中断, 比如说 ctrl-c ,时间中断,用于多进程, 缺页中断,用于高效利用内存空间, 还有异常,I/O中断 等等

这样, 我们就基本上罗列了操作系统所有需要实现的几个功能: 
1. 内存管理
2. 进程管理
3. 文件管理
4. 网络管理
5. 中断管理

这些功能的使用, 就只能在内核态下运行. 
而每一个计算任务本身, 就是在用户态下执行.

> 上面的每一个概念, 实际上都是代码, 然后都是二进制. 我们需要用我们的逻辑, 来一个一个用代码实现他们.

# level 3 deep dive , final section , and start section 
## How OS started? 分段, 存储地址等等安排

上面我聊到的每一个模块, driver , 内存管理, 文件管理, 中断管理, 都需要我们来进行实现, 最终, 他们也会变成二进制, 或者说,变成一个软件, 存放在磁盘当中. 
即然是二进制, cpu 就要按照一步一步的执行.
这里的每一步, 就是程序的地址.
当我们计算机接上电源, 按下开机键的一刻,将磁盘当中的操作系统加载到内存当中,
cpu 的 cs ip 寄存器开始从 0x7cff 地址执行代码. 将操作系统的各个模块进行初始化. 
我们的操作系统的各个模块就开始初始化, 最终作为操作系统运行.

而各个模块的开发,就是内核研发人员需要去做的事情.
    
