 这是一个 read 操作
 它分别有三个参数, file, buffer, size
 buffer的作用, 是在内存当中申请一块空间来存储需要读取的文件.
 size 则限定了 buffer 的大小.
 我们来详细看一下 file 这个参数,
 它会包含文件状态, 比如说被打开,被关闭.
 然后还有权限, 包含可读或者可写.
 最重要的呢,就是 inode, 又称 index node.
 它包含了文件的元数据,比如说文件大小, 文件类型.
 在访问之前,它需要被添加锁,从而避免重复性的读写 ,
 最关键的, 还是它所指向的磁盘中块的位置.
 假设我们的 read 访问的, 是4号和5号两个块.

 这是我们要访问的磁盘,
 文件系统初始化的过程中,它的起始位置会设置为超级块.
 然后, 我们大部分剩余的磁盘空间被分成一个又一个的块并被编上号码.
 而superblock也就是超级块当中, 会被记录上 inode 的数量, 以及块的数量
 当然还有其他信息, 我们的视频不做涉及.
 在我们的视频当中呢, 假设一个小方格为一个块.
 而 inode ,则是包含了多个块的一个数据结构.
 回到我们 read 的操作, read, 它根据 inode 里面获取到了 4, 5 两个块的编号.
 剩下要做的, 就是将其内容读取到 buffer 当中即可.

# XV6 的 READ 系统调用如何实现的?

READ 基本上是所有进程都需要涉及到的系统调用.
当我们执行一个进程的时候, 当我们要打开一个文件的时候,当我们播放音乐的时候,都会涉及到READ操作.

而我们的问题是: READ 在执行的时候, 到底做了什么事情?

首先, read 是一个系统调用,
当我们执行READ的时候,我们需要了解第一个信息就是 
文件描述符,这样,我们就

读写文件内容的系统调用是read和write。read系统调用有三个参数：一个指定所操作的文件描述符，一个指定读取数据的存放地址，最后一个指定读多少个字节。在C程序中调用该系统调用的方法如下：

```
count = read(filehandle, buffer, nbytes);
```



在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口fs\_struct
```
struct fs_struct {
    struct inode *pwd;                //进程当前执行目录的内存inode指针
    struct file *filemap;             //进程打开文件的数组
    atomic_t fs_count;                //访问此文件的线程个数？？
    semaphore_t fs_sem;                //确保对进程控制块中fs_struct的互斥访问
};
```

当创建一个进程后，该进程的fs\_struct将会被初始化或复制父进程的fs\_struct。当用户进程打开一个文件时，将从filemap数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。

- read 要知道buff的位置是什么? size 的大小
- read 然后需要得到文件描述符.也就是需要读取的文件.
- 这个时候, 我们会判断文件的mode.
- 判断这个文件是否被其他人阅读. 也就是, 添加一个锁.
- 一个文件对象, 添加上锁.
- 添加锁以后, 这个文件对象的inode 对象开始向下移动. 

开一个新的 screen, 添加一个磁盘对象. 
磁盘对象里面的扇区一个一个的转换成一个缓冲区.

- inode 是如何在磁盘上获取到位置的? 
- 运算的方式是如何工作的?
- copy 数据回去.




