from manim import *

def WhatIsBpf(Scene):
    def construct(self):

        pass

    # 我们知道内核一般分为用户态和内核态.
    # 内核态将负责对硬件进行调度工作.
    # 而用户态则使用内核态的系统调用, 来实现各种各样的应用程序或者服务.
    # 在使用应用程序的过程当中, 我们不可避免的将面临 debug 或者扩展内核功能的需求.
    # 举个例子来说, 我们需要抓取网络数据包, 或者我们需要知道某个系统调用
    # 一般来说, 我们在面临这种需求的时候,会考虑等一等内核从业者去实现这个功能.
    # 

    # 这是我们的 Linux 内核
    # 在内核中, 有一个叫做 bpf 的虚拟机
    # 它用于将 bpf 的指令翻译成机器码. 
    # 当我们书写一个 bpf 程序后, 它会被编译成字节码, 然后被内核加载
    # 之后, 内核会将字节码交给 bpf 虚拟机执行
    # bpf 虚拟机会将字节码翻译成机器码, 然后执行

    # 作为一个需要执行代码的虚拟机, bpf 虚拟机需要有一套自己的指令集
    # 这些指令集被称为 bpf 指令集
    # 其次, 代码执行的过程当中, 一定会有一些数据需要被处理
    # 在普通的执行过程当中, 我们会有两个东西来存储数据: 栈 & 堆 
    # 那么, 在 bpf 当中, 我们也有一个栈
    # 但是, 我们没有堆
    # 取而代之的, 我们使用的是 ebpf map. 
    # ebpf map 是一种特殊的数据结构, 它可以在内核空间和用户空间之间共享数据
    # 也就是说, 我们可以在用户空间中创建一个 ebpf map, 然后在内核空间中读写它
    # 这样, 我们就可以在用户空间和内核空间之间共享数据了

    # 让我们来看一个例子
    # 当我们开始执行一个 ebpf 程序时, 我们会使用 bpf()) 系统调用来加载这个程序 
    # 紧接着, 我们将创建一个 bpfmap 
    # 随后, 我们的这个 bpf 程序将附加到 socket 操作事件上.
    # 当这个tcp 接收事件发生时, 我们的 bpf 程序就会在 bpf 虚拟机中执行
    # 而在执行的过程当中, 我们会执行 bpf syscall, 对 map 进行读写操作
    # 比如说, 获取下一个 key , BPF_GET_NEXT_KEY
    # 从 map 当中找到数据, BPF_MAP_LOOKUP_ELEM
    # 更新 map 当中的数据, BPF_MAP_UPDATE_ELEM
    # 删除 map 当中的数据, BPF_MAP_DELETE_ELEM
