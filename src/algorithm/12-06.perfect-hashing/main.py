from manim import *

BACKGROUND="#2B3A42"

WORD_A="#00CED1"
WORD_B="#FFD700"
OBJ_A="#3EB489"
OBJ_B="#FFC0CB"
OBJ_C="#FFA500"

SHADOW="#D3D3D3"


# https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic
class PerfectHashing(Scene):

    def __init__(self):
        super().__init__()
        self.camera.background_color = BACKGROUND

    def birthday_paradox(self):
# 第一节 生日悖论
        # 问你一个问题, 你们的班级现在有 23 个人，假设每个人的生日是随机的，那么至少有两个人生日相同的概率是多少呢？
        # 答案可能超乎你的想象, 50.7%

    ### 形式化证明 ###
        # 为什么会这样呢？我们来看看这个问题的解决过程
        # 首先我们来看看只有两个人的情况
        # 两个人的生日相同的概率是 1/365
        # 也就是说两个人的生日不同的概率是 364/365, 那么 23 个人的生日都不同的概率是多少呢？

        # 364/365 * 363/365 * 362/365 * ... * 343/365
        # 这个概率是 49.3%
        # 那么至少有两个人生日相同的概率是多少呢？
        # 1 - 49.3% = 50.7%

### 第二节, 碰撞概率无限趋近于0
        # 这就是著名的生日悖论,
        # 而生日悖论, 可以应用在很多的场景当中, 我们今天要论述的, 就是一种叫做完美哈希的算法
        # 完美哈希, 顾名思义, 就是完美的, 没有冲突的哈希算法,

        # 其实我们再重新看生日悖论. 可以看到它和我们的哈希算法也是有共通之处的.
        # 我们来看看生日悖论的描述:
        # 在一个班级, 有23个人, 他们中有两个人同一天的生日的概率是50.7%
        # 也就是说, 23 个人, 它们被存储在 365 个位置当中, 有两个人存储在同一个位置的概率是50.7%
        # 用哈希来表达就是, 将23元素映射到365当中, 存在两个元素在同个位置或者说碰撞概率为 50.7%
        # 再抽象一点, n 个元素, 映射到 约等于 n 平方的位置当中, 存在碰撞的概率为 50.7%
        # 即然是完美哈希,  50.7 对于我们来说, 显然是不够的. 
        # 我们要做到更优秀, 让它无限接近于零. 
        # 问题是, 怎么做呢?
        #
        # 我们有 U 个元素, 我们要把这 U 个元素映射到一个数组 m 当中. 
        # 首先, 我们会有 m 个 slut , 然后用于执行二极哈希表. 
        # 这样的情况下, 每个二极哈希表的大小都不会相同.
        # 在我们的例子当中, 我们假设 m1 所指向的哈希表大小是 l1 
        # m2 指向 l2
        # 有的表可能会为0 
        # 
        # 当我们在创建这个哈希表的时候, 有三个细节需要注意: 
        # 细节一就是, 我们的二极哈希表的大小, 不是 l1, l2, l3 的大小. 而是, l1的平凡, l2 的平方, l3 的平方, 以此类推.
        # 细节二, 我们选择的哈希函数, 是从通用哈希函数当中选取, 从而可以保证每个位置的碰撞概率一致, 且为 1/l1.
        # 细节三, 当我们从通用哈希函数选取的函数发生了碰撞,我们将重新从通用哈希函数中随机再选择一个.
        # 这三个细节, 构成了我们的完美哈希函数. 
        # 这个时候, 有人就说了, 你说构成就构成? 怎么证明呢? 
        # 接下来, 我们就用可视化 + 形式化的方法来证明这一点. 

    ### 形式化证明 ###
        # 

# 第三节, 空间大小.
        # 我们回到这个哈希表本身,  有人就会问, 你这样, 每一次都给 l1, l2, l3 进行平方, 那这样, 如果我要存储的大小是 1m, 岂不是要用掉 1m 平方的空间. 这是不可接受的呀.
        # 我们也同意这一点, 完美哈希如果说空间占用率达到如此之高, 也就称不上完美了. 
        # 所以, 实际上, 我们可以证明的是, 完美哈希的空间占用率, 仍然为 O(n) 

    ### 形式化证明 ###

        pass

    def construct(self):
        self.birthday_paradox()
