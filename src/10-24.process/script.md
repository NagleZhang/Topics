        # 这是我们的一个程序.其中的代码存放在 .text 段当中.
        # 程序被执行后, 就变成了进程.
        # 我们的 cpu 会执行 cs ip 所指向的指令.
        # 当 CPU 在执行该程序的指令的时候,它就进入了 RUNNING 的状态.
        # 程序不断的向前执行, 遇到循环等分支,会重复执行部分代码.
        # 进程之间也会发生切换的情况.
        # 在我们的实例当中,进程切换到另外一个进程后, 原有进程的状态就变成了 RUNNABLE
        # 接下来, 如果需要将进程切换回来,我们需要做哪些事情?
        # 我们看一下  xv6 的实现.
        # 进程状态被枚举为 procstate
        # 进程本身, 由 proc 这个结构来进行管理
        # 即然我们需要将进程切换回来, 首先需要知道我们切换的是谁, 于是我们需要进程的 ID
        # 这里, 我们假设原进程是0 , 
        # 切换后的进程是 1
        # 在proc这个结构当中, 用 pid 来表示. sz 呢则代表的是 process 的大小.
        # 而进程0和进程1都有自己的页表.
        # 我们需要从页表1切换到页表0, 这个被结构体当中的 pgdir 管理.
        # 接下来, 进程在切换过程当中,有一些上下文环境,比如说当前指令位置ip寄存器.
        # 然后, 栈的地址, sp 
        # 这些信息呢会存储在 context 这个结构当中.
        # 还有中断信息,在进程被被切换一般都是会发生系统调用从而陷入内核态,并且发生切换.具体的系统调用如何分发,
        # 以及分发后的上下文切换.
        # 这个,就需要 trapfram 来进行管理.
        # 而在切换到内核态以后,内核本身也需要对该进程的内核态上下文保存, 所以我们需要一个栈, 也就是 kstack 来保存其上下文信息.
        # 当然了, 我们程序的文件地址也需要被修改, 它们被 inode, 和 cwd两个字段来进行管理.
        # 其中cwd就是 current directory,当前文件路径的意思
        # 最后还有进程管理链表本身需要的: 比如说父进程,是否被杀死等等辅助信息.
        # 在切换到进程0的proc管理的这些数据以后.
        # 我们就完成了从进程1回到进程0的切换, 于是进程 0 变成了 running 的状态.
